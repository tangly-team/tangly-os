== Simple Dependency Injection for Java


thre denpendcy injection package is a small dependency injection _DI_ library for java projects.

It's designed for small projects that don't need a full-blown dependency injection framework.
To be as simple as possible the library has less features compared to other DI frameworks and some limitations:
- Only constructor injection is supported, **no** setter/field injection
- No `PostConstruct` or `PreDestroy`
- Uses some JSR-330 annotations (`javax.inject.*`) but is **not** a compliant implementation of JSR-330
- Java 8 or higher

== User Manual

=== 1. Add the library to your project

There are two ways of using the library in your project:

1. Use a Build-System like Gradle or Maven.


=== 2. Create your classes

Write your Java classes. When your class needs an instance of another class, simply add this dependency as a constructor parameter.


```java
public class Car {

    private final Engine engine;

    public Car(Engine engine){
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        engine.accelerate();
    }
}

public class Engine {
    public void start(){
        ...
    }

    public void accelerate(){
        ...
    }
}
```

=== 3. How to get instances of your classes

```java
import net.tangly.commons.di.Injector;

public class CarApp {

    public static void main(String...args){
        Injector injector = new Injector();

        final Car car = injector.getInstance(Car.class);

        car.drive();
    }
}
```

For this simple use case you do not need any annotations or configuration.

== Optional Features

=== Multiple Constructors

When a class has more then one public constructor, you need to define which one it should use. This is done with the annotation `javax.inject.Inject`:

```java
public class Car {
    ...
    @Inject
    public Car(Engine engine){
        // this constructor will be used
        ...
    }

    public Car(){
        ...
    }
}
```

=== Interfaces and Implementing classes

The library doesn't know which implementing class it should use when an interface type is requested as a dependency.
You have to tell it with the `injector.bindInterface(interfaceType, implementingType)` method.

```java
public interface Engine {}

public class GasolineEngine implements Engine {}

public class ElectricMotor implements Engine {}


Injector injector = new Injector();
injector.bindInterface(Engine.class, ElectricMotor.class);
...

final Engine engine = injector.getInstance(Engine.class);

assertThat(engine).isInstanceOf(ElectricMotor.class);
```

=== Singletons

By default the library will create new instances every time a dependency is requested. If there should only be a single instance of a specific class
you have to tell. There are two ways of doing this:

==== 1. @Singleton

The recommended way is to use the `javax.inject.Singleton` annotation on the class that should be a singleton:

```java
@Singleton
public class Car {
...
}
```

==== 2. Injector.bindSingleton()

You can mark a class as singleton with the method `markAsSingleton`. This is useful when you for some reason can't
modify the source code of the class (i.e. when it is part of a third-party library).

```java
Injector injector = new Injector();

injector.markAsSingleton(ThirdParty.class);
...
```

=== Providers

If you like to inject instances of a class that doesn't meet the requirements you can add a `javax.inject.Provider`
for this class. There are many use cases where this can be useful:

- There is only a factory method to get instances of this class but no constructors
- There is no public constructor or there are more than one public constructors and (for some reason) you can't add the `@Inject` annotation
- The class is implemented with the [classical Singleton design pattern](https://en.wikipedia.org/wiki/Singleton_pattern#Example).
- You need to make some configuration on the created instance before it can be used for injection.
- You like to use abstract classes as dependency (see next section)

```java
Injector injector = new Injector();

injector.bindProvider(Engine.class, new Provider<Engine>() {
    @Override
    public Engine get(){
        Engine engine = new Engine();
        engine.configureThis();
        engine.configureThat();
        return engine;
    }
});
```

With Java 8 lambdas you would write this:

```java
injector.bindProvider(Engine.class, ()-> {
    Engine engine = new Engine();
    engine.configureThis();
    engine.configureThat();
    return engine;
});
```

=== Abstract classes

If an instance of an abstract class is requested, you can't know out of the box which implementing class it should use.

This is the same situation as with interfaces. Unlike interfaces at the moment there is no explicit way of defining a binding for abstract classes.
The reason is that there are far more possibilities for (miss-)configuration when it comes to (abstract) class bindings.

When you like to use abstract classes as dependencies you will have to [create a provider](#providers) for this class.

=== Bind instances

In some use cases you like to define that one specific instance is injected every time the given type is requested. This is like a singleton
configuration only that you define the exact instance on your own instead of only defining that the given type is a singleton and let create
the instance.

```java
Engine engine = new Engine();
injector.bindInstance(Engine.class, engine);
```

This is a shortcut for this:

```java
Engine engine = new Engine();
injector.bindProvider(Engine.class, () -> engine);
```

The `bindInstance` method can also be used to configure instances for interfaces or abstract classes.

If you need to get instances from the dependency injection container in your business code you should use a `Provider` as
constructor argument with the generic type of the classes you want to get. See the [Lazy Injection](#lazy-injection--lazy-instantiation) section.


If you still need the possibility to get instances of various types in your business code you should probably use this approach:

```java
public interface InstanceProvider {
    <T> T getInstance(Class<T> type);
}

// in your main class

Injector context = new Injector();
context.bindProvider(InstanceProvider.class, () -> context::getInstance);



// in your business code
public class Example {

    private InstanceProvider context;

    public Example(InstanceProvider context){
        this.context = context;
    }

    public void doSomething(){
        Other other = context.getInstance(Other.class);
        ...
    }
}
```

This approach has some advantages over the previous one:
- no dependency to the library in your business code anymore. This way switching to another DI library in the future should be easier.
- It's not possible to (accidentally) re-configure the context outside of your main class.
- No way to mess up the singleton scope anymore.
If you forget the `bindProvider` configuration in the example you will now get an expressive error message that there is no provider for the interface `InstanceProvider` found.

---

## Note on Circular Dependencies

When using constructor injection without a DI framework, it isn't possible to
create circular dependencies. Look at the following example:

```java
public class A {
    public A (B b){}
}

public class B {
    public B (C c){}
}

public class C {
    public C (A a){}
}
```

You can't instantiate any of these classes with `new` because you can't provide the needed constructor params (except you pass `null` as
constructor param). If you try to get an instance of one of these classes you will get an `IllegalStageException`:

```java
Injector injector = new Injector();

injector.getInstance(A.class); // IllegalStateException
```

Creating circular dependencies is generally a bad idea because it leads to tight coupling.
