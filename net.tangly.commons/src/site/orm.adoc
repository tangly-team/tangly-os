---
title: "ORM"
date: 2019-05-01
weight: 20
draft: false
---

:author: Marcel Baumann
:email: <marcel.baumann@tangly.net>
:revnumber: v0.1
:revdate: 2020-05-31
:homepage: https://www.tangly.net/
:company: https://www.tangly.net/[tangly llc]
:copyright: CC-BY-SA 4.0
:icons: font
:source-highlighter: pygments
:pygments-style: manni

== Purpose

[quote,Theodore Roosevelt]
In any moment of decision, the best thing you can do is the right thing, the next best thing you can do is the wrong thing, the worst thing you can do is nothing.‚Äù

Orm provides a mapper between Java objects and relational databases.
The ORM should be simplistic and provide minimal functions.
Major design constraints are

* The persisted Java classes do not need to be edited.
The approach support hexagonal architecture.
The framework does not rely on inheritance or annotations to perform its duty.
Your domain model stays clean of implementation impurities.
* No magic byte code manipulation.
The POJO are not modified by the ORM library,
* No external configuation based on XML or JSON,
* Only a basic set of operations and abstractions are supported, no advanced capabilities are provided.

Interactions with ORM have two parts.
You build a DAO using a DAO builder.
The builder defines the mapping between simple properties and columns in table and relationships between classes and associated tables.

The DAO defines the mapping between a Java class with all its properties and relations to other classes.
It provides functions to close the gap between Java objects and rows in a relational database.

== User Manual

The DAO builder provides a fluent interface.
For the examples we use the class _Entity_ as persistable class.
All persistable classes must implement the _HasOid_ interface and declare a unique primary key as _BIGINT oid_ in the SQL table definition.
You can chain all the properties and relations definitions in one statement.

The _Entity_ Java class declaration is

[source,java]
----
    class Entity implements HasOid {
        private Long oid;
        private String name;
        private LocalDate date;

        private Entitiy one2one;
        private List<ReferenceType> one2many;

        private private Set<Value> jsonValues;
        private final Set<Tag> tags;
        private final List<Comment> comments;
    }
----

The _Entity_, _ReferenceType_ and _Comment_ DDL SQL declarations are

[source,sql]
----
CREATE TABLE schema.entities
(
    oid        BIGINT PRIMARY KEY,
    name       VARCHAR(64),
    date       DATE,
    one2one    BIGINT,
    jsonValues CLOB,
    tags       CLOB,
    FOREIGN KEY (one2one) REFERENCES schema.entities(oid)
);

CREATE TABLE schema.referenceType
(
    oid        BIGINT PRIMARY KEY,
    entityFid  BIGINT,
    FOREIGN KEY (entityFid) REFERENCES schema.entities(oid)
);

CREATE TABLE schema.comments
(
    oid     BIGINT PRIMARY KEY,
    created DATETIME    NOT NULL,
    author  VARCHAR(64) NOT NULL,
    text    CLOB,
    tags    CLOB,
    ownedBy BIGINT      NOT NULL
);

----

.Create DaoBuilder<T>
[source,java]
----
    DaoBuilder<Entity> entitiesBuilder = new DaoBuilder<Entity>(Entity.class).withOid();
----

.Add simple Property (string, date, etc.)
[source,java]
----
    entitiesBuilder.withString("name").withDate("date");
----

.Add One 2 One Property
Below the definition of *1 -> 1* relation on the same class.
The entity class has a property _one2one_ referencing a referenced or owned instance of class entity.
A reference to the entity DAO is provived through the _self()_ method.
The boolean parameter states that the instance at the end of the relation is owned.

The _one2one_ field is declared as a column in the SQL table with the same name and of type BIGINT.

The naming of _one2one_ shall follow Java and SQL naming conventions.

[source,java]
----
    entitiesBuilder.withOne2One("one2one", entitiesBuilder.self(), true);
----

.Add One 2 Many Property
Below the definition of *1 -> 1* relation on the class _ReferenceType_.
The entity class has a property _one2many_ referencing a list of referenced or owned instances of type _ReferenceType_.
The property _entityFid_ is the foreign key declared in class _ReferenceType_ to implement the relation.
The SQL table of _ReferenceType_ has a column _BIGINT entityFid_.
The boolean parameter states that the instance at the end of the relation is owned.

The naming of _one2many_ and "entityFid" shall follow Java and SQL naming conventions.

[source,java]
----
    entitiesBuilder.withOne2Many("one2many", "entityFid", Reference.of(ReferenceTypeDao), false);
----

.Add JSON Property
The _Value_ class is the type of the values to be converted to JSON for storage in the database and converted to Java objects when retrieved from the database.
The transformation process uses the Jackson library.

The _jsonValues_ relation shall be a collection in the Java class.
The SQL column declaration has the form _jsonValues CLOB_.

[source,java]
----
    entitiesBuilder..withJson("jsonValues", Value.class);
----

.Add Tags
[source,java]
----
    entitiesBuilder.withTags("tags");
----

.Add Comments
Comments are handled as a regular *1 -> N* owned relation.

[source,java]
----
    entitiesBuilder..withOne2Many("comments", "ownedBy", Reference.of(comments), true);
----

.Create Dao<T>
[source,java]
----
    Dao<Entity> entities = entitiesBuilder.build("schema", "entities", datasource);
----

The DAO instance can create and update instances with _update_, find instances with _find(...), and delete instances with _delete_.

== Entities

Using the library means accepting some restrictions on how your entities both as Java classes and as SQL schema are designed.
Some of these restrictions are good practices regardless of how database and object models are built.

=== Java Objects

* Every entity class should have a numeric *Long* identifier field named *oid* that will be used as a mandatory primary key.
** The library will populate this identifier field.
** The primary key will be used when the library performs updates in the underlying database.
* The library expects to work with entities with public getters and setters or with entities with public getters for fields.
** A special mode is available for immutable objects, in particular Java _record_ having only getters.

* Entities can contain lists of other entities.
In this case, the object containing the other entities is referred to as the owner, and the entities in its list, its owned objects.
** The _update_ operation is transitive and updates all referenced objects.
** The _delete_ operation is transitive and all owned objects will be discarded from the persistent store.
** References between entities are accomplished through their primary keys in the database, but through object references in Java.

Entity models that do not follow the practices above will be difficult or impossible to support using hrorm.

=== SQL Schema

* The library expects every table to have a numeric long primary key.
* The library will populate the primary keys on inserts with an unique key value.
* The key value is unique through all objects implicitly supporting polymorphic references in relations.

=== Relations

One point of using a relational database as opposed to a document store or other mechanism is to preserve the structure of relations between entities.
The impedence mismatach is delegated to the developer who shall declare a private property for each foreign key; no access methods need to be created.

All relations are directional in the programming language.
Four kinds of relations are identified (the arrow shows the direction of the relation in Java).

N -> 1::
. most efficient mapping of a relation in the programming language.
.. Updates of the referencing object will always updates all referenced objects.
. The property of the object referencing the object simply contains an _optional_ or _mandatory_ ownee object.
. The relation is modeled with a foreign key in the referencing table to the unique identifier of the referenced object table.
.. The property name contains the referenced instance in the Java object.
.. The column name in the reference table is the name of the property and have the sql type _BIGINT_.
.. THe relation can only implement the reference mode and never the owned mode because no unique owner exists.
. The unique identifier of the referenced object is stored as foreign key in the referencing object.
.. You can define a foreign key constraint if desired on the reference table.
Therefore we must first persist the owned object, and then the owner object.

1 -> 1::
. is a special case of *N -> 1* relation and can efficiently be map in the programming language.
.. Updates of the referencing object will always updates all referenced objects.
. The property of the object referencing the object simply contains an _optional_ or _mandatory_ ownee object.
. The relation is modeled with a foreign key in the referencing table to the unique identifier of the referenced object table.
.. The property name contains the referenced instance in the Java object.
.. The column name in the reference table is the name of the property and have the sql type _BIGINT_.
.. THe relation can only the reference mode and the owned mode because a unique owner exists.
. The unique identifier of the referenced object is stored as foreign key in the referencing object.
.. You can define a foreign key constraint if desired on the reference table.
. If the referencing object owns the referenced object it will be transitively deleted.

1 -> N::
. The property is a list of referenced objects.
.. All referenced objects have the same type.
.. Updates of the referencing object will always updates all referenced objects.
. The relation is modeled with a foreign key in the referenced table.
.. You can define a foreign key constraint if desired on the referenced table.
. If the referencing object owns the referenced object it will be transitively deleted.

N -> M::
. Is not supported.
Please be aware that this kind of relation is not available in Java programming language.
. In Java you can emulate *N -> M* with additional correlation classes.
Please transform the relation to two *1 -> N* with a correlation class and table.

[NOTE]
====
Owning relations are often called *Parent-Child* relations.
Owning relations imply transitive updates and deletions.

Referenced relations are often called *Sibling* relations.
Referenced relations imply only transitive updates.
The business logic is responsible for handling expected deletions.
====

One tricky thing about these relationships is the reversal in how ownership is expressed between the database schema and the object model.
Insert, update and delete operations have to handle the reversal accordingly.
This rule is only relevant if the owned object as a new object, meaning the __oid__ is __UNDEFINED_ID__.
Otherwise the integrity rules are already fulfilled in the database.

== Extensions

.Comments
Comments are handled as a regular entity and the object having comments has a 1 -- N relation with the comment entity.

.Tags
Tags are handled as a JSON field and are stored as emdedded list in the object having the tags.
Support for tag type is provided.

.Reference Codes
Reference code are handled as a local property and the code key is stored in the database.
Sopport for code type is provided.

.Json Properties
To be written

== Data Access Objects Design

[plantuml,orm-classes,svg]
----
@startuml

class Dao <T extends HasOid> {
}

Dao *-- Property
Dao *-- PropertyOne2Many

class PropertyOne2One<T extends HasOid, R extends HasOid>  {}


class DaoBuilder <T extends HasOid> {
    + Dao<T> build(String schema, String entity, DataSource dataSource)
}


class DaoValidator <T extends HasOid> {}

interface Property <T extends HasOid> {}

interface Relation <T extends HasOid, R extends HasOid> {}

class PropertySimple <T extends HasOid>

Property <|.. PropertySimple

class PropertyOne2One<T extends HasOid, R extends HasOid> {}

PropertySimple <|-- PropertyOne2One
Relation <|-- PropertyOne2One

class PropertyOne2Many<T extends HasOid, R extends HasOid> {}

Property <|.. PropertyOne2Many
Relation <|.. PropertyOne2Many

class PropertyJson<T extends HasOid, V> {}
PropertySimple <|-- PropertyJson

@enduml
----

== History

* _0.2.x_ The mapper was extended to support owned entities and sibling entities.
Both are updated upon a save operation.
If an owner instance is deleted all his owned entities will transitively be deleted.
Business logic is responsible for the handling of sibling lifecycles.
The examples in the unit tests and the documentation were extended.
* _0.2.x_ The initial implementation is tested against hsqldb.
No effort was invested to test compatibility with other databases.
The port should be straight forward because we are using plain JDBC statements.
* _0.2.x_ A major drive to create the library is the ease of support for reference code, tags and comments.
We are still looking for open source libraries providing hooks to support such extensions.
