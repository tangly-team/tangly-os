---
title: "Actors"
linkTitle: "Actors"
date: 2024-05-02
tags: ["java", "architecture"]
---

== Reflections on Actor Models
:author: Marcel Baumann
:email: <marcel.baumann@tangly.net>
:homepage: https://www.tangly.net/
:company: https://www.tangly.net/[tangly llc]

image::2024-05-02-head.svg[width=420,height=360,role=left]

Concurrent programming has always been tricky.
Accessing a shared state from multiple threads is a central problem, where hard-to-catch errors may easily appear.
Java has all the instruments for safe and flawless concurrency, but the compiler would deliberately let developers write dangerous code.
There is a strong need for higher-level frameworks ensuring safe concurrent programming.

The actor model is one of the approaches to safe concurrency.

Understand that, although multiple actors can run at the same time, an actor will process a given message sequentially.
This means that if you send 3 messages to the same actor, it will just execute one at a time.
To have these 3 messages being executed concurrently, you need to create 3 actors and send one message each.

Messages are sent asynchronously to an actor, that needs to store them somewhere while it’s processing another message.
The mailbox is the place where these messages are stored.

Another interesting aspect of the actor model is that it doesn’t matter if the actor that I am sending a message to is running locally or in another node.

An actor is a computational entity that, in response to a message it receives, can concurrently:

- Send a finite number of messages to other actors.
- Create a finite number of new actors.
- Designate the behavior to be used for the next message it receives.

=== Advantages and Downsides

Here are four benefits of this model that can answer this question:

. It removes the need for lock-based synchronization.
Actors can change only their private state; other actors’ states are off-limits to them.
There’s no shared state in the actor model, so there’s no possibility of that disaster when multiple threads try to modify the same data.
. It was designed for distributed computing.
Every actor has a mailbox that stores messages until they can be processed.
It does not matter if the actor runs locally or on another device.
As long as it can receive messages, it makes no difference.
That’s a major difference compared to CSP.
. It allows for better scalability.
If your actor-based solution sees an increase in traffic load, you can create more actors and assign them the same address.
Actors can also be programmed to create child actors under certain conditions.
This makes scaling an application a lot easier.
. It does not require the sender to block waiting for a return value.
This is an overall benefit of using messaging instead of method calls.
The receiver will send a return value in another message when it’s done handling the original one.
The sender can send out more messages in the meantime.

Actor-based concurrency comes with some drawbacks.
Here are three of them:

. Actors process messages one at a time.
So, if several actors send five messages to the same receiving actor, it’ll execute them one after the other.
If you need these messages executed simultaneously, you’ll need five different actors running simultaneously.
. Deadlock is still possible.
Two actors may end up waiting for a message from each other, thus creating a deadlock.
Overall, the model is considered susceptible to deadlocks.
(However, it’s worth noting that concurrent programming, in general, is more error-prone and complex than sequential programming.)
. You need to enforce message immutability.
Using the actor model in languages that don’t enforce immutability out of the box means it’s up to the developer to ensure messages remain immutable.
If this verification is overlooked, messages may become mutable – and lead to thread-safety concerns.
. Unexpected failures can be critical.
If an actor failure occurs, other actors may get perpetually stuck awaiting a message from it – a message that won’t arrive because of the failure.
To avoid this situation, developers have to employ defensive programming techniques and handle exceptions within the scope of each actor.
=== Minimal Actor Library

To send a message to an actor, you need a reference to the receiving entity.

Introduce naming conventions if your application profits from search capabilities.
An actor should have a unique external identifier to support querying.

Consider using a sealed class hierarchy to define messages actors receive.
Modern pattern matching in Java provides elegant solutions.

virtual thread executor

=== Publish and Subscribe with Flow

multiple publishers and multiple consumers for a channel

=== Finite State Machines

The behavior of an actor is specified as a flat or a hierarchical state machine.

=== Sealed Types and Pattern Matching

Message load type can be defined as a closed sealed type hierarchy.
Pattern matching with _instanceof_ would provide exhaustive and type secure handling of all alternatives.

[bibliography]
=== Links

- [[[actor-model, 1]]] https://en.wikipedia.org/wiki/Actor_model[Actor Model].
Wikipedia.
- [[[message-passing, 2]]] https://en.wikipedia.org/wiki/Message_passing[Message Passing].
Wikipedia.

=== References

bibliography:[]
