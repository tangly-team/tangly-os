---
title: "Structure Your Concurrency"
linkTitle: "Structure Concurrency"
date: 2024-04-01
tags: ["java", "students-java"]
---

include::../fragments/_config-mb-blog.aodc[]

image::2024-04-01-head.png[width=420,height=360,role=left]

Writing concurrent software is one of the greatest challenges for software developers cite:[modern-software-engineering,effective-java-3rd].

Java thread model makes it a strong contender among concurrent languages, but multithreading has always been inherently tricky.

The introduction of _virtual threads_ empowered Java to provide a unique and highly-optimized threading system that is also easy to understand.
You can now create millions of threads without the overhead of creating a native operating system thread.

Now you need mechanisms to manage this huge number of threads.

Virtual threads, now an official feature of Java, create the possibility of cheaply spawning threads to gain concurrent performance.
As a result, Java now has a unique and highly-optimized threading system that is also easy to understand.

How do you cope with a huge number of threads?

How do you process huge collections?

How do you process data flows with back pressure?

How do you design distributed and reactive systems?

== Structured Concurrency

Structured concurrency enhances the maintainability, reliability, and observability of multithreaded code.
It adopts a concurrent programming style that reduces the likelihood of thread leaks and cancellation delay.
These are common risks associated with cancellation and shutdown.

As the JEP for structured concurrency says, _If a task splits into concurrent subtasks, then they all return to the same place, namely the task's code block_.

Structured concurrency is a programming paradigm that provides a way to write concurrent software using familiar program flows and constructs.
It guarantees that all concurrent tasks are properly managed and cleaned up when leaving the scope of the _try with resources_ block.

[source,java]
----
try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
    Future<Shelter> shelter = scope.fork(this::getShelter);
    Future<List<Dog>> dogs = scope.fork(this::getDogs);
    scope.join();
    Response response = new Response(shelter.resultNow(), dogs.resultNow());
    // ...
}
----

When exiting the try-with-resources block, the structured concurrency framework ensures that all concurrent tasks are properly managed and cleaned up.

== Concurrent Stream Processing

[.float-group]
--
image::2024-04-01-parallel-stream.png[width=420,height=360,role=left]

Java 8 introduced the Stream API, which provides a way to process data in a declarative manner cite:[functional-programming-java].

Java Streams support parallel processing, but the parallelism is not structured.

The parallelism is processing bound and not I/O bound.
Therefore, the maximum number of active threads should be limited to the number of available processor cores.

The parallel stream is cleanup upon completion of the terminal operation.
--

[source,java]
----
List<Integer> listOfNumbers = Arrays.asList(1, 2, 3, 4);
int sum = listOfNumbers.parallelStream().reduce(5, Integer::sum);
----

== Concurrent Data Flow Processing

[.float-group]
--
image::2024-04-01-reactive.png[width=420,height=360,role=left]

Concurrent data flow processing is based on the Reactive Streams API.
It is a specification for asynchronous stream processing with non-blocking back pressure.

The processing pipeline is composed of a source, a set of operators, and a sink.

The reactive library takes care of the threading and back pressure.
--

== Distributed and Reactive Systems

[.float-group]
--
image::2024-04-01-actor.png[width=420,height=360,role=left]

The actor model is a programming model for concurrency in a distributed system.
It is based on the concept of actors, which are independent entities that communicate with each other by sending messages.

Each actor has its own mailbox and processes messages one at a time.
An actor only accesses its own state and does not share state with other actors.

An actor is an active object that encapsulates state and behavior and is implemented as a concurrent process.
--

== Lessons Learnt

Between virtual threads and structured concurrency, Java developers have a compelling new mechanism for breaking up almost any code into concurrent tasks without much overhead.
An application developer almost never uses concurrency primitives or thread pools directly.

Library developers can use the new concurrency primitives to build high-performance libraries that are easy to use.

Use parallel streams when processing huge collections.

Use reactive programming when processing data flows with back pressure, different sampling rates, and complex event processing.

Use the actor model when designing distributed and reactive systems.

[bibliography]
== Links

- [[[modern-java-algebric-data-types, 1]]] link:../../2024/data-classes-sealed-types-and-pattern-matching[Data Classes, Sealed Types and Pattern Matching]
Marcel Baumann. 2024
- [[[modern-java-advanced-streams, 2]]] link:../../2024/advanced-streams[Advanced Streams]
Marcel Baumann. 2024
- [[[modern-java-modules, 3]]] link:../../2024/java-modules[Java Modules]
Marcel Baumann. 2024
- [[[modern-java-structured-concurency, 4]]] link:../../2024/structure-your-concurrency[Structured Concurrency]
Marcel Baumann. 2024

== References

bibliography::[]
