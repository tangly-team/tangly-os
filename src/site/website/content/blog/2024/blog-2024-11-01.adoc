---
title: "Domain Entities UI"
linkTitle: "Domain Entities UI"
date: 2024-11-01
tags: ["java", "architecture"]
params:
  featured: "blog/2024/pics/2024-11-01-head.jpg"
---

include::../fragments/_config-mb-blog.adoc[]

image::2024-11-01-head.jpg[width=420,height=360,role=left]

Commercial digital applications regularly display a list of entities and details for selected one.
The selected entity can be displayed, edited, deleted.
A new entity can be created.
This pattern is called https://en.wikipedia.org/wiki/Create,_read,_update_and_delete[CRUD].

[TIP]
====
DDD practitioners complain that it was hard to gain commitment from business stakeholders, or even to completely engage them.
My own experience suggested that it was nearly impossible to engage business managers with UML diagrams.
It was much easier to engage them in rapid prototyping where they could see and interact with the results.

Even if you could engage the sponsors to design a domain model, by the time you have finished developing the system on top, most of its benefits had disappeared.
It is nice creating an agile domain object model, but if any change to that model also dictates the modification of the layers above and underneath, then that agility is worthless.

The other concern that gave rise to the birth of https://en.wikipedia.org/wiki/Naked_objects[Naked Objects] was how to make user interfaces of mainstream business systems expressive.
Most business systems are not at all expressive.
They treat the user merely as a dumb process-follower, rather than as an empowered problem-solver.

Domain-driven design realized that if the domain model represents the _ubiquitous language_ of the business, those domain objects should be behaviorally rich.
Business logic is encapsulated as methods on the domain objects rather than in procedural scripts on top of them.

The next step the user interface is a reflection of the domain model.
It would make it easier to do domain-driven design, because one could easily translate evolving domain modeling ideas into a working prototype.
And it would deliver an expressive, object-oriented user interface for free.
====

== Grid Display

The key concepts are filtering and ordering of the selected items per column.

== Operations with a Selected Entity

The standard read, update, delete and create operations are supported.
An additional creation variant is the duplicate operation to minimize user inputs.

== Business Operations

== Events

Changes in the system are communicated via events.
Domain-driven design promotes asynchronous event communication between the bounded contexts.

The same mechanism is used to communicate changes in the domain entities to the multiple UI instances.

[NOTE]
====
The event bus is a simple in-memory event bus using the Java `Flow` API and default implemenation.
No additional libraries are necessary.

The processing of received events is asynchronous and performed in backgounds threads.
====

=== Internal Events

Internal events are used to notify the system about changes in the domain entities and update the UI accordingly.
All internal events are sent over a domain-specific event bus.

Care is taken to publish UI changes on the UI thread. {ref-vaadin} provides a mechanism to execute code on the UI thread.

[source, java]
----
UI.getCurrent().access(() -> v.ifPresent(View::refresh)));              <1>
----
<1> First, the current UI in which the user component is exected is obtained.
Second, The action is posted on the user interface thread with the `access` method.

=== External Events

A bounded domain can register and receive external events from other domains.
Each domain publishes events to a domain-specific public event bus.
All public events created by the domain are sent over its public event bus instance.

Interested parties can subscribe to the public event bus and receive events.
The receiving and processing of events is done asynchronously in the background threads.

These external events often update the domain model and trigger internal events.
These interval events then update the UI instances.

[NOTE]
====
A user interface instance is created for each tab in the browser.
Multiple users can work with the same domain entities in parallel.

When a tab or a browser is closed, the user interface instance is destroyed.
It triggers a cleanup of the user interface domain entities.
One important housekeeping operation unregisters the UI instance from the internal event bus.
This logic is implemented in the `BoundedDomainClass' abstraction.
====

== Extensions

== Lessons Learnt

The domain entities UI is a key part of the domain-driven design.
Mechanisms to display, edit, and create domain entities are essential.
The multi-user and multi-tab support runs in a multi-threaded environment and requires careful programming to scale.
All the logic is provided by the domain entities UI framework to diminish complexity for the application developers.

[bibliography]
== Links

== References

bibliography::[]
