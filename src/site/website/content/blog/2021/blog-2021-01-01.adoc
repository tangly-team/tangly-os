---
title: "Value Objects as Embedded Entities"
linkTitle: "Value Objects"
date: 2021-01-10
tags: ["design", "crm"]
---

== Value Objects as Embedded Entities
:author: Marcel Baumann
:email: <marcel.baumann@tangly.net>
:homepage: https://www.tangly.net/
:company: https://www.tangly.net/[tangly llc]
:copyright: CC-BY-SA 4.0

image::2021-01-01-head.png[720, 480, role=left]

=== Value Objects

This post is about the value object pattern and the factory pattern which are tactical patterns in domain driven design (DDD).
Value objects define the second kind of domain objects besides entities.
Their main characteristic is immutability: _Attributes of a value object never change_.

Value objects do have attributes and methods as entities.
Attributes of value objects are immutable though which implies that methods of value objects can only be queries, never commands that change the internal state of an object.
We can pass value objects to clients through getters for example without worrying that they change them.

Many objects can be modeled as value objects instead of entities because they are defined through their attributes.
These objects measure, quantify or describe things in the domain model.
Because they are so easy to handle we should model as many value objects as possible.

=== Design Decisions

==== Addresses, Phone Numbers, Email Addresses

Some value objects are part of any commercial application domain.
Postal addresses, phone numbers and email addresses are canonical value objects.

This means that these objects do not have an object identifier and should not be stored in a seperate table if stored in a SQL database.
Value objects shall be embedded objects and part of an object such as a person.

A person should have an external identifier and has a postal address, multiple phone numbers, and one or more email addresses.

Check your domain model and validate the above assumptions.

* Postal address, phone numbers, email addresses are value objects and have not object identifiers.
* They are always owned by other entities such as persons, companies, delivery forms.
* They are immutable objects.
* Business processes can replace such an object with a new instance without impeding other domain instances.

==== Invoice Lines

Invoice lines are lines in an invoices. Invoice lines are always value objects belonging to exactly one invoice.

To complicate matter, invoice lines have different types such as a regular line with a specific article, quantity, unit price and price for the quantity.
Often VAT aspects must be considered and computed for the overall invoice. An invoice line can also be a subtotal for a set of regular invoice lines.

The following design challenges exist

* Serialization libraries such as JSON Jackson library cannot handle invoice lines with multiple Java class types.
 A workable approach is described and implemented the open source component https://tangly-team.bitbucket.io/docs/gleam/[Gleam].
 The approach is to define selectors to instantiate the correct Java class/
* Invoices are complex objects and ideal candidates for a document oriented persistent approach.
 Invoices should not be stored in a relation based persistence store, meaning a SQL database.

=== Factories

The factory pattern in DDD can be seen as a super pattern for the Gang of Four (GoF) creational patterns.
Factories are concerned with creating new entities and value objects.
They also validate the invariants for the newly created objects.
We can place a factory on the entity or value object itself or an independent object.

Factories that are placed on the same object they create are either factory methods or prototype methods.
The factory method creates a completely new object from the method parameters.
The prototype method uses an existing instance to derive a new object.

When the creation logic is complex or has dependencies that are not needed by the created object it is best to create a separate factory.
This factory could then provide multiple ways to create new instances.

==== Value Objects in Persistent Store

We encourage experimenting with the https://microstream.one/[MicroStream] approach for small projects.
The effort to persist a Java object graph is very small.
You can always move to a no SQL solution when your application is succesfull and time is come to harden it.
