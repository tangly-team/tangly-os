---
title: "Java, Groovy, Clojure"
linkTitle: "Java, Groovy, Clojure"
date: 2022-04-01
tags: ["agile", "java", "students"]
---

== Three JVM Languages: Java, Groovy, Clojure
:author: Marcel Baumann
:email: <marcel.baumann@tangly.net>
:homepage: https://www.tangly.net/
:company: https://www.tangly.net/[tangly llc]

image::2022-04-01-head.png[width=420,height=360,role=left]

Professional software developers shall master their primary technology stack and programming language.
I am a proficient and experienced programmer in Java.
I have written production code in Java for the last twenty years.
I decided to study the language in depth and acquired various Java developer certifications.
I truly love the modern Java language and the available development environments.

I want to understand the strengths and weaknesses of Java as well.
Knowing the weaknesses of my technology stack empowers me to select alternative design approaches to mitigate the drawbacks.

An approach to gathering data is to learn more about Groovy and Clojure.
I want to understand the various strengths of different programming languages.
I still want to stay in the Java ecosystem to better apply my learnings.
Both Groovy and Clojure are available on the Java virtual machine and have good interoperability with it.

One major focus is the functional programming approach and hwo it impacts design and development activities.

=== Clojure

Clojure is the functional programming language and a Lisp(1) dialect.
The language compiles to and runs on the JVM and interfaces nicely with Java and API libraries.

[quote,Alan J. Perlis]
____
It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.
____

Clojure is a Lisp dialect not constrained by backward compatibility.

* Extends the code-as-data paradigm to maps, sets and vectors
* Defaults to immutability
* Core data structures are extensible abstractions
* Provides approaches to concurrent programming
* Embraces the JVM platform

==== Expressions and Statements

[source,clojure]
----
; binds a name to a value. If value is an expression it is first evaluated.
(def <name> <value>)

; else is optional, if not present the expression returns null in the false case
(if (<condition>) (<true-expression>) (<false-expression))

; when is conceptually an if with only a true path
(when (<condition>) (<true-expression>))

; when not is conceptually an if with only a false path
(when-not (<condition>) (<false-expression>))

; cond process on condition after another, the expression of the first condition being true is executed and the expression completes.
(cond
  (<condition-1) (expression-1)
  (condition-2) (expression-2)
  :else (expression-else))

(case <value>
 <value-1> <expression>
 <value-2> <expression>
 <expression-else>)

(loop [] (expression-loop))

(do {expression})
----

Number tower Truth

==== Functions and Closures

Functions are a key construct for a functional language.
You can define functions and closures using:

[source,clojure]
----
(def <name> (fn [] (<expressions)))

(defn name [] (<expression>))

let [{<name> <expression}] (<expression>))

letfn[] (<expression>)
----

===== Higher-order Functions and Sequences

Sequence abstraction permeates the design and API of Clojure.
Functional programming emphasizes the design of functions working on generic data structures.

===== Recursion, Tail Recursion, Currying, Memoization

loop recur partial memoize

=== Thoughts

Type hints Spec

=== Java

==== Expressions and Statements

[source,java]
----

----

==== Functions and Lambdas

You can define functions and lambdas using:

===== Higher-order Functions and Streams

===== Recursion, Tail Recursion, Currying, Memoization

=== Thoughts

=== Groovy

==== Expressions and Statements

One cool feature of Groovy is the support of operators as syntactic sugar.
I would welcome this feature in Java.
I dream of writing legible expressions with _BigInt_ or _BigDecimal_ types.
The current method call approach destroys the legibility of the source code.

[source,groovy]
----

----

==== Functions and Lambdas

You can define functions and lambdas using:

===== Higher-order Functions and Sequences

===== Recursion, Tail Recursion, Currying, Memoization

=== Thoughts

