---
title: "Java, Groovy, Clojure"
linkTitle: "Java, Groovy, Clojure"
date: 2022-04-05
tags: ["agile", "java", "students"]
---

== Three JVM Languages: Java, Groovy, Clojure
:author: Marcel Baumann
:email: <marcel.baumann@tangly.net>
:homepage: https://www.tangly.net/
:company: https://www.tangly.net/[tangly llc]

image::2022-04-01-head.png[width=420,height=360,role=left]

Professional software developers shall master their primary technology stack and programming language.
I am a proficient and experienced programmer in Java.
I have written production code in Java for the last twenty years.
I decided to study the language in depth and acquired various Java developer certifications.
I truly love the modern Java language and the available development environments.

I want to understand the strengths and weaknesses of Java as well.
Knowing the weaknesses of my technology stack empowers me to select alternative design approaches to mitigate the drawbacks.

An approach to gathering data is to learn more about Groovy and Clojure.
I want to understand the various strengths of different programming languages.
I still want to stay in the Java ecosystem to better apply my learnings.
Both Groovy and Clojure are available on the Java virtual machine and have good interoperability with it.

One major focus is the functional programming approach and hwo it impacts design and development activities.

=== Clojure

Clojure is the functional programming language and a Lisp(1) dialect.
The language compiles to and runs on the JVM and interfaces nicely with Java and API libraries.

[quote,Alan J. Perlis]
____
It is better to have 100 functions operate on one data structure than to have 10 functions operate on 10 data structures.
____

Clojure is a Lisp dialect not constrained by backward compatibility.

* Extends the code-as-data paradigm to maps, sets and vectors
* Defaults to immutability
* Core data structures are extensible abstractions
* Provides approaches to concurrent programming
* Embraces the JVM platform

==== Expressions and Statements

[source,clojure]
----
; binds a name to a value. If value is an expression, it is first evaluated.
(def <name> <value>)

; else is optional, if not present the expression returns null in the false case
(if (<condition>) (<true-expression>) (<false-expression))

; conceptually when is an if with only a true path
(when (<condition>) (<true-expression>))

; conceptually when not is an if with only a false path
(when-not (<condition>) (<false-expression>))

; cond process on condition after another, the expression of the first condition being true is executed and the expression completes.
(cond
  (<condition-1) (expression-1)
  (condition-2) (expression-2)
  :else (expression-else))

(case <value>
 <value-1> <expression>
 <value-2> <expression>
 <expression-else>)

(loop [] (expression-loop))

(do {expression})
----

Number tower Truth

==== Functions and Closures

Functions are a key construct for a functional language.
You can define functions and closures using:

[source,clojure]
----
(def <name> (fn [] (<expressions)))

(defn name [] (<expression>))

let [{<name> <expression}] (<expression>))

letfn[] (<expression>)
----

===== Higher-order Functions and Sequences

Sequence abstraction permeates the design and API of Clojure.
Functional programming emphasizes the design of functions working on generic data structures.

The powerful advandage of dynamic typed language is that algorithms just work with various parameters.
As long as the parameters support the required functions, there is no need to provide a specific interface.

===== Recursion, Tail Recursion, Currying, Memoization

loop recur partial memoize

=== Thoughts

Type hints Spec

=== Java

==== Expressions and Statements

[source,java]
----

----

==== Functions and Lambdas

You can define functions and lambdas using:

===== Higher-order Functions and Streams

===== Recursion, Tail Recursion, Currying, Memoization

=== Thoughts

=== Groovy

==== Expressions and Statements

One cool feature of Groovy is the support of operators as syntactic sugar.
I would welcome this feature in Java.
I dream of writing legible expressions with _BigInt_ or _BigDecimal_ types.
The current method call approach destroys the legibility of the source code.

[source,groovy]
----

----

==== Functions and Lambdas

You can define functions and lambdas using:

===== Higher-order Functions and Sequences

===== Recursion, Tail Recursion, Currying, Memoization

=== Thoughts

Clojure is brilliant in the support of dynamic dispatch at runtime.
The refined design of their collections is a proof of their support for functional approaches.
I am not convinced that dynamic inheritance and protocols promote maintainability of software products.

Java is slowly moving to improve their support:

- Switch expressions are now way more functional.
In Spring 2022 deconstruction of records, objects and arrays is still not available.
- First class citizen status for functions is still ongoing.
You still not define the implementation of a virtual method using the lambda notation or a method reference.
I agree it is a detail.
But it is a signal if you want to truly support functional approaches.
- Nice is the effort to improve the collections.
The sequence interface would improve the legibility of the standard collections.
It is still a hack that unmodifiable collection throws an exception if your code calls a modifier.
It is time to introduce a unmodifiable interface for the various collections.

Groovy is awesome in how operator support enhances the legibility of the source code.
The implementation is syntactic sugar.

Java libraries are best of breed.
Backward compatibility and static type checks are a must for enterprise applications developed over decades.
You do not want to throw away such a huge investment.

I like properties and the elegance of grouping the declaration of the field with the methods.
I am still not certain it makes the code quite more legible or maintainable.

If you want to write a functional code with immutable objects, the availability of a with construct is a huge improvement.

And as engineer, I truly acknowledge the performance edge of Java against Clojure or Groovy.
Newer approaches based on GraalVM should close the performance gap in the future.
