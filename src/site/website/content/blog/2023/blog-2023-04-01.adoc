---
title: "Software Developer Assumptions"
linkTitle: "Software Developer Assumptions"
date: 2023-04-10
tags: ["java", "architecture", "series-students"]
---

== Software Development Assumptions
:author: Marcel Baumann
:email: <marcel.baumann@tangly.net>
:homepage: https://www.tangly.net/
:company: https://www.tangly.net/[tangly llc]

image::2023-04-01-head.jpg[width=420,height=360,role=left]

Software development topics I learnt to like after 40 years in the industry.

I worked at quite a few industrial and commercial digital product development initiatives.
I truly enjoyed creating successful solutions.

Over the years, I encountered similar architecture and design patterns when creating source code for these applications.

Again and again, our teams had to find ways to learn, tackle complexity, improve cohesion, and master coupling.

Modern engineers create increasingly complex and sophisticated systems.

So as well as focusing on learning and modern engineering, we need to focus on managing complexity cite:[modern-software-engineering].

We need to focus our tools, techniques and mindset on dealing with the complexity
cite:[modern-software-engineering,building-evolutionary-architectures-2nd,clean-architecture].

=== Strongly Agree

I strongly agree with these statements:

* Typed languages are better when you are working on a team of people with various experience levels.
* Stand-ups are actually useful for keeping an eye on the newbies.
They help to detect a team member stuck in a loop.
* Sprint retrospectives have their place so long as they are for actual course correction.
They are the _holy shit, well that went poorly!_, and not some awful scrum master driven waste of everyone's time.
* Developers should not be isolated or left to just code.
Bypassing TPMs, PMs, and talking directly to the customer always reveals more about the problem, in less time, and with higher accuracy.
* Software architecture matters probably more than anything else.
A shitty implementation of a good abstraction causes no net harm to the code base.
A bad abstraction or missing layer causes everything to rot.
* Java is quite a cool language.
* Clever code is not usually good code.
Clarity trumps all other concerns.
* Bad code can be written in any paradigm.
* So-called _best practices_ are contextual and not broadly applicable.
Call them _good practices_.
Blindly following them makes you a fool.
The agile community recognized the dangers.
They only advocate _good practices_ and emphasize the importance of the context in which they are applied.
* Designing scalable systems when you do not need to makes you a bad engineer.
* Static analysis is actually useful.
* DRY is about avoiding a specific problem, not an end goal unto itself.
* In general, RDBMS are better and simpler than NoSql solutions.
* Functional programming is another tool, not a panacea.
The real world has objects and often classes.

=== Positive Experience

I learnt to appreciate these approaches:

* https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it[YAGNI], https://en.wikipedia.org/wiki/SOLID[SOLID],
https://en.wikipedia.org/wiki/Don%27t_repeat_yourself[DRY], https://en.wikipedia.org/wiki/KISS_principle[KISS].
* Pencil and paper are the best programming tools and vastly underused.
* Trading purity in exchange for practicality is usually a good call.
* Adding more technology in response to a minor problem is rarely a good call.
* Design is driven from requirements cite:[domain-driven-design].
Building anything beyond those requirements puts you into the world of speculative, self-indulgent invention.
* 90%, maybe 95%, of project managers, could probably disappear tomorrow to either no effect or a net gain in efficiency cite:[large-scale-scrum].
* After performing over 2000 interviews, I can say that standard human resources interviewing is thoroughly broken.
Technical interviewing and peer interviewing work way better and is more accurate.
* Agile approaches are more successful and more fun.
Waterfall approaches suck.
* Static websites with Asciidoc are the solution how to document your architecture and technical product.

=== Old Beliefs

I still think these statements should be applied:

* A software developer shall have formal training in computer science and software engineering.
She should hold at least a bachelor degree.
* A junior Java developer shall pursue a formal Java programmer certification.
The learning effect is not always huge, but as a team member, I have security that they know all basic concepts.
* People who stress over code style, linting rules, or other minutia are insane weirdos.
* Code coverage has absolutely nothing to do with code quality.
* Monoliths are pretty good in most circumstances.
* Micro-services require justification.

=== References

bibliography::[]
