---
title: "Distributed Systems"
linkTitle: "Distributed Systems"
date: 2025-01-01
tags: ["java", "architecture"]
---

== Distributed Asynchronous Systems
:author: Marcel Baumann
:email: <marcel.baumann@tangly.net>
:homepage: https://www.tangly.net/
:company: https://www.tangly.net/[tangly llc]

image::2025-01-01-head.png[width=420,height=360,role=left]

The embedded software industry is in the midst of a major revolution.
A Tremendous amount of new development lays ahead.
This new embedded software needs an actual architecture that is inherently safer and easier to understand.
It provides a higher level of abstraction than the usual _free-threading_ approach based on a traditional Real-Time Operating System (RTOS).

For years, experts in concurrent software have been pointing out that unrestricted use of threads and various blocking mechanisms of an RTOS.
It often leads to programs that are unsafe and difficult to reason about.
Instead, experts from different industries independently came up with the following best practices, collectively known as the active object or actor design pattern:

1. Keep data isolated and bound to threads.
Threads should hide and encapsulate their private data and other resources.
They should *not* share them with the rest of the system.
2. Communicate among threads asynchronously via event objects.
Events also called messages.
Using asynchronous events keeps the threads running truly independently, without ever blocking on each other.
3. Threads should spend their lifetime responding to incoming events.
Their mainline should consist of an event-loop that handles events one at a time to completion, thus avoiding any concurrency hazards within a thread itself.

While these best practices can be applied manually on top of a traditional RTOS, a better way is to use an actor library.
The main difference is that when you use an RTOS, you write the main body of the application such as the thread routines for all your tasks.
You call explicitly the RTOS synchronisation services, e.g., a semaphore, a monitor, a lock or a time delay.

When you use a framework, you reuse the overall architecture and write mainly the application code that the framework will call.
This leads to inversion of control and allows the framework to automatically enforce the best practices of concurrent programming.
In contrast, a raw RTOS lets you do anything and offers no help or protection for the best practices.
The other important difference is that the event-driven actor framework really represents a paradigm shift from a traditional RTOS.

In the resource-constrained embedded systems, the biggest concern has always been about the size and efficiency of such active object frameworks, especially that the frameworks accompanying various modeling tools have traditionally been built on top of a conventional RTOS, which adds memory footprint and CPU overhead to the final solution.

But perhaps the most important benefit of active object frameworks is that they offer a much higher level of abstraction.
You can apply the right abstractions for formal design techniques such as hierarchical state machines, UML state charts modeling, and automatic code generation.

All of this means the event-driven architecture is not only possible in deeply embedded, high-reliability systems, but it is actually ideal for such applications.

=== Distributed Asynchronous Embedded Systems

image::2025-01-01-uml-state-machine.gif[width=420,height=360,role=left]
Communication over Messages::
Communication between components is solely through message passing.
You either send messages directly to another actor, or use a publishing and subscribe metaphor with topics.
The topic approach has a lesser https://en.wikipedia.org/wiki/Coupling_(computer_programming)[coupling] and is easier to extend.
No Synchronous Calls:::
Synchronous calls have always a blocking semantic.
Under load, liveliness and deadlock problems often occur.
Asynchronous solutions have only deadlock if the https://en.wikipedia.org/wiki/Abstract_state_machine[state machines of communicating actors have a specification error.
Powerful techniques from the telecommunication industry, e.g. ITU SDL, can detect such flaws through formal validation.
Messages are Value Objects:::]
To be written
Typed Messages::
To be written
Idempotent Messages::
The system can be resilient if idempotent message design is systematically used.
Distributed systems cannot always guaranty single delivery of a specific message without additional sometimes prohibitive costs.
Idempotency can be realized syntactically with a message identifier or semantically by providing invariants for multiple processing of the same message.
Actors are State Machines::
Actors define the internal state of a node.
The processing of a message can trigger an action and a state change.
Therefore, actors should always be implemented as state machines.
Nodes are single-Threaded:::
Multi-threaded support shall be provided through the library.
Avoid as much as possible to implement multithreaded solutions inside an actor.

[source,cpp]
----
State state = INIT;                         <1>

switch (state) {
    case STATE_1:
        switch (message.id) {               <2>
            case (ID_A):
                action_a(message);          <3>
                state = STATE_2;
                break;
            case (ID_B):
                action_b(message);
                state = STATE_N;
                break;
            ...
        }
    ...
}
----

<1> Current state of the actor.
The type of the variable should be an enumeration.
<2> Identify the message through is identifier.
A message should be a value object.
<3> Implement the transition from state _STATE_1_ to _STATE_2_ and execute the associated action _action_a_.
It is customary to pass the message as parameter to the function.

The same code in Java would be:

[source,java]
----
State state = INIT;

state = switch (state) {
    case STATE_1 ->
        switch (message.id) {
            case (ID_A):
                action_a(message);
                yield STATE_2;
            case (ID_B):
                action_b(message);
                yield STATE_N;
            ...
        }
    ...
}
----

[CAUTION]
====
The above programmatic approach is limited to flat state machines.

Hierarchical state charts as described in UML notation can only be efficiently implemented with a state machine library.
An example of such a library for the Java stack is link:../../../docs/fsm[net.tangly:fsm_].
If you are using this notation, avoid parallel states.
Parallel states require multithreaded nodes and the semantic is not well-defined.
====

=== Theory

Global Time::
Distributed systems often have timeouts in their business logic.
The implementation of these requirements is way easier if all nodes in the system have access to a global time.
The time is always very handy to generate log records with a system-wide natural sort order.
https://en.wikipedia.org/wiki/Network_Time_Protocol[Network time protocol] is a concrete implementation to provide global time in a distributed environment.
CAP Theorem::
https://www.ros.org/[ROS-2 Robotic Operating System] is constrained through CAP theorem.
Topics Based and Message-Passing Architecture Quality of Services Asynchronous Messages vs Services Single Threaded Node communication with UML diagram and State machine in C++.
Eventual Consistency::
https://en.wikipedia.org/wiki/Eventual_consistency[Eventual consistency] is a consistency model used in distributed computing to achieve high availability.
It informally guarantees that, if no new updates are made to a given data item, eventually all accesses to that item will return the last updated value.
A distributed machine will only support eventual consistency.
If you want to provide ACID, you would need to lock down all sensors and actuators during a distributed transaction.
This is obviously not possible if your machine is processing a request or moving material.

=== Lessons Learnt

Never try to transform a distributed asynchronous system into a synchronously centrally controlled application.
Smells are polling to find out configuration and statuses.
The worst code starts to add delays, timeouts, and retries to build an image of the distributed solution.
It will never work.
You are trying to ignore the CAP theorem.

[WARNING]
====
Distributed asynchronous systems always imply a distributed message-based asynchronous architecture.
This design always promotes eventual consistency.

You will never have an atomic global state of the system.
====

[bibliography]
=== Links

=== References

bibliography::[]
